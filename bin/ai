#!/usr/bin/env bash
# PayReady AI Unified CLI - Single entry point for all AI operations
# Version: 3.0.0
# Date: September 18, 2025

set -euo pipefail

# Directories
PAYREADY_HOME="${PAYREADY_HOME:-$HOME/.payready}"
PAYREADY_BIN="$(dirname "$0")"
CONFIG_DIR="$HOME/.config/payready"

# Colours
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log() { echo -e "${GREEN}[AI]${NC} $*" >&2; }
error() { echo -e "${RED}[ERROR]${NC} $*" >&2; exit 1; }
debug() { [[ "${AI_DEBUG:-false}" == "true" ]] && echo -e "${CYAN}[DEBUG]${NC} $*" >&2; }

log_event() {
    local payload="$1"
    local log_path=".project/memory/cli.log.jsonl"
    mkdir -p "${log_path%/*}"
    printf '%s\n' "$payload" >> "$log_path"
}

record_error() {
    local rc="$1"
    local line="$2"
    local ts
    ts=$(date -Iseconds 2>/dev/null || date)
    log_event "{\"ts\":\"$ts\",\"event\":\"cli_error\",\"rc\":$rc,\"line\":$line}"
}

trap 'record_error $? $LINENO' ERR

load_env_file() {
    local file="$1"
    [[ -f "$file" ]] && source "$file"
}

mkdir -p "$CONFIG_DIR"
set -a
load_env_file "$CONFIG_DIR/env.core"
load_env_file "$CONFIG_DIR/env.services"
load_env_file "$CONFIG_DIR/env.llm"
for env_file in "$CONFIG_DIR"/env.*; do
    case "$env_file" in
        "$CONFIG_DIR/env.core"|"$CONFIG_DIR/env.services"|"$CONFIG_DIR/env.llm")
            ;;
        *)
            load_env_file "$env_file"
            ;;
    esac
done
set +a

validate_environment() {
    local -a warnings=()
    local has_valid_key=false

    if [[ -n "${PORTKEY_API_KEY:-}" ]]; then
        has_valid_key=true
    fi

    if [[ -n "${OPENROUTER_API_KEY:-}" ]] && [[ "${OPENROUTER_API_KEY}" != *"YOUR_KEY"* ]]; then
        has_valid_key=true
    elif [[ -z "${PORTKEY_API_KEY:-}" ]]; then
        warnings+=("OPENROUTER_API_KEY not configured - fallback routing disabled")
    fi

    if [[ "$has_valid_key" == "false" ]]; then
        error "At least one valid API key required: PORTKEY_API_KEY or OPENROUTER_API_KEY"
    fi

    if [[ -z "${PORTKEY_API_KEY:-}" ]]; then
        warnings+=("PORTKEY_API_KEY not configured - using OpenRouter only")
    fi

    if (( ${#warnings[@]} )); then
        for warning in "${warnings[@]}"; do
            debug "$warning"
        done
    fi
}

# ============================================================================
# Authentication Management
# ============================================================================

get_auth_method() {
    # All models now use Portkey/OpenRouter routing
    echo "portkey"
}

get_virtual_key() {
    local intent="$1"

    # Return appropriate virtual key based on intent
    # Updated Sept 2025 with optimal provider mapping
    case "$intent" in
        code)
            # X.AI Grok - Best for code generation
            echo "${PORTKEY_VK_XAI:-xai-vk-e65d0f}"
            ;;
        analyze)
            # Claude Opus 4.1 - Best for analysis
            echo "${PORTKEY_VK_ANTHROPIC:-anthropic-vk-b42804}"
            ;;
        design)
            # OpenAI GPT - Best for architecture
            echo "${PORTKEY_VK_OPENAI:-openai-vk-e36279}"
            ;;
        search)
            # OpenAI GPT-5 mini for research/search tasks
            echo "${PORTKEY_VK_OPENAI:-openai-vk-e36279}"
            ;;
        fast)
            # OpenAI GPT-OSS for fast drafting
            echo "${PORTKEY_VK_OPENAI:-openai-vk-e36279}"
            ;;
        deep)
            # DeepSeek v3 - Complex reasoning
            echo "${PORTKEY_VK_DEEPSEEK:-deepseek-vk-24102f}"
            ;;
        *)
            # Default to Anthropic for balanced general responses
            echo "${PORTKEY_VK_ANTHROPIC:-anthropic-vk-b42804}"
            ;;
    esac
}

# ============================================================================
# Model Selection
# ============================================================================

detect_intent() {
    local query="$1"
    # Portable lowercase conversion (works on BSD/macOS and GNU/Linux)
    local query_lower=$(echo "$query" | tr '[:upper:]' '[:lower:]')

    # Fast responses -> Groq
    if [[ "$query_lower" =~ (quick|fast|brief|simple|tldr) ]]; then
        echo "fast"
        return
    fi

    if [[ "$query_lower" =~ (solve|algorithm|math|proof|reason|complex) ]]; then
        echo "deep"
        return
    fi

    if [[ "$query_lower" =~ (design|architect|plan|system|integrate) ]]; then
        echo "design"
        return
    fi

    if [[ "$query_lower" =~ (analyze|review|audit|examine|understand|explain) ]]; then
        echo "analyze"
        return
    fi

    if [[ "$query_lower" =~ (search|latest|current|recent|news|2025) ]]; then
        echo "search"
        return
    fi

    if [[ "$query_lower" =~ (code|function|class|script|module) ]]; then
        echo "code"
        return
    fi

    echo "general"
}

select_model() {
    local intent="$1"

    case "$intent" in
        design)
            echo "openai/gpt-4.1-mini"
            ;;
        analyze)
            echo "anthropic/claude-opus-4.1"
            ;;
        search)
            echo "openai/gpt-5-mini"
            ;;
        fast)
            echo "openai/gpt-oss-120b"
            ;;
        deep)
            echo "deepseek/deepseek-chat-v3-0324"
            ;;
        code)
            echo "x-ai/grok-code-fast-1"
            ;;
        general)
            echo "anthropic/claude-sonnet-4"
            ;;
        *)
            echo "anthropic/claude-sonnet-4"
            ;;
    esac
}

# ============================================================================
# Request Execution
# ============================================================================


execute_portkey() {
    local query="$1"
    local model="$2"
    local vk="$3"

    local escaped_query
    escaped_query=$(printf '%s' "$query" | jq -Rs .)
    local request_body
    request_body=$(cat <<EOF
{
    "model": "$model",
    "messages": [{"role": "user", "content": $escaped_query}],
    "max_tokens": 2000
}
EOF
)

    local trace_id="${PAYREADY_TRACE_ID:-pr-$(uuidgen 2>/dev/null || date +%s)}"
    local portkey_config_default='{"retry":{"attempts":3,"on_status_codes":[408,429,500,502,503,504]}}'
    local portkey_config="${PORTKEY_CONFIG_JSON:-$portkey_config_default}"
    local portkey_timeout="${PORTKEY_REQUEST_TIMEOUT_MS:-8000}"
    local portkey_url="${PORTKEY_BASE_URL:-https://api.portkey.ai/v1}/chat/completions"

    local body_file
    body_file=$(mktemp)
    local response=""

    if [[ -n "${PORTKEY_API_KEY:-}" ]]; then
        local config_header trace_header timeout_header
        printf -v config_header 'x-portkey-config: %s' "$portkey_config"
        printf -v trace_header 'x-portkey-trace-id: %s' "$trace_id"
        printf -v timeout_header 'x-portkey-request-timeout: %s' "$portkey_timeout"

        log "Using $model via Portkey..."
        set +e
        local portkey_status
        portkey_status=$(curl -sS --fail-with-body \
            -o "$body_file" \
            -w '%{http_code}' \
            "$portkey_url" \
            -H "content-type: application/json" \
            -H "x-portkey-api-key: ${PORTKEY_API_KEY}" \
            -H "x-portkey-virtual-key: ${vk}" \
            -H "$timeout_header" \
            -H "$trace_header" \
            -H "$config_header" \
            -d "$request_body")
        local curl_exit=$?
        set -e

        if [[ $curl_exit -eq 0 && ${portkey_status:-0} -lt 400 ]]; then
            response=$(cat "$body_file")
            rm -f "$body_file"
            log_event "{\"ts\":\"$(date -Iseconds 2>/dev/null || date)\",\"event\":\"llm_request\",\"provider\":\"portkey\",\"model\":\"$model\",\"http_status\":${portkey_status},\"trace_id\":\"$trace_id\"}"
            [[ "${AI_DEBUG:-false}" == "true" ]] && echo "Portkey response: ${response:0:200}..." >&2
            echo "$response" | jq -r '.choices[0].message.content // .error.message // "Error: Invalid response"' 2>/dev/null || echo "Error: Failed to parse response"
            return
        fi

        debug "Portkey call failed (exit=${curl_exit}, status=${portkey_status:-n/a})"
        if [[ -s "$body_file" ]]; then
            debug "Portkey body: $(head -c 200 "$body_file")"
        fi
    fi

    rm -f "$body_file"

    if [[ -n "${OPENROUTER_API_KEY:-}" ]]; then
        log "Falling back to OpenRouter..."
        local or_file
        or_file=$(mktemp)
        set +e
        local openrouter_status
        openrouter_status=$(curl -sS --fail-with-body \
            -o "$or_file" \
            -w '%{http_code}' \
            https://openrouter.ai/api/v1/chat/completions \
            -H "authorization: Bearer ${OPENROUTER_API_KEY}" \
            -H "content-type: application/json" \
            -H "http-referer: ${OPENROUTER_REFERER:-https://payready.ai/tools}" \
            -H "x-title: ${OPENROUTER_TITLE:-PayReady CLI}" \
            -d "$request_body")
        local or_exit=$?
        set -e

        response=$(cat "$or_file")
        rm -f "$or_file"

        if [[ $or_exit -eq 0 && ${openrouter_status:-0} -lt 400 ]]; then
            log_event "{\"ts\":\"$(date -Iseconds 2>/dev/null || date)\",\"event\":\"llm_request\",\"provider\":\"openrouter\",\"model\":\"$model\",\"http_status\":${openrouter_status}}"
            [[ "${AI_DEBUG:-false}" == "true" ]] && echo "OpenRouter response: ${response:0:200}..." >&2
            echo "$response" | jq -r '.choices[0].message.content // .error.message // "Error: Invalid response"' 2>/dev/null || echo "Error: Failed to parse response"
            return
        fi

        debug "OpenRouter call failed (exit=${or_exit}, status=${openrouter_status:-n/a})"
        if [[ -n "$response" ]]; then
            debug "OpenRouter body: ${response:0:200}"
        fi
    fi

    error "LLM request failed. Check Portkey/OpenRouter credentials or service status."
}


# ============================================================================
# Main Execution
# ============================================================================

main() {
    local query=""
    local explicit_model=""
    local verbose=false
    local show_help=false

    # Validate environment for non-help commands
    if [[ "$*" != *"--help"* ]] && [[ "$*" != *"-h"* ]]; then
        validate_environment
    fi

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --model|-m)
                [[ -z "${2:-}" ]] && error "Model option requires a value"
                explicit_model="$2"
                shift 2
                ;;
            --verbose|-v)
                verbose=true
                AI_DEBUG=true
                shift
                ;;
            --help|-h)
                show_help=true
                shift
                ;;
            config|auth|test|doctor|remember|recall|memory)
                # Special commands
                handle_special_command "$@"
                exit 0
                ;;
            -*)
                error "Unknown option: $1"
                ;;
            *)
                query="$*"
                break
                ;;
        esac
    done

    # Show help if needed
    if [[ "$show_help" == "true" ]] || [[ -z "$query" ]]; then
        show_usage
        exit 0
    fi

    # Validate query length
    if [[ ${#query} -gt 4000 ]]; then
        error "Query too long (max 4000 characters)"
    fi

    # Validate required tools
    command -v jq >/dev/null || error "jq is required but not installed"
    command -v curl >/dev/null || error "curl is required but not installed"

    # Detect intent and select model
    local intent=$(detect_intent "$query")
    local model="${explicit_model:-$(select_model "$intent")}"

    debug "Intent: $intent"
    debug "Model: $model"

    # Add context
    local context_query="$query (context: $(date +%Y-%m-%d), project: $(basename "$PWD"))"

    # Execute via Portkey/OpenRouter
    local vk=$(get_virtual_key "$intent")
    debug "Virtual key: $vk, Model: $model, Intent: $intent"
    local response=$(execute_portkey "$context_query" "$model" "$vk")

    # Output the response
    echo "$response"

    # Skip memory logging for now - it's broken
    true
}

# ============================================================================
# Special Commands
# ============================================================================

handle_special_command() {
    local command="$1"
    shift

    case "$command" in
        config)
            handle_config "$@"
            ;;
        auth)
            handle_auth "$@"
            ;;
        test)
            run_tests "$@"
            ;;
        doctor)
            run_doctor
            ;;
        remember|recall|memory)
            handle_memory "$command" "$@"
            ;;
        *)
            error "Unknown command: $command"
            ;;
    esac
}

handle_config() {
    local action="${1:-list}"

    case "$action" in
        list)
            echo "Current Configuration:"
            echo "  PORTKEY_API_KEY: ${PORTKEY_API_KEY:0:10}..."
            echo "  Default Model: $(select_model 'default')"
            echo "  Debug Mode: ${AI_DEBUG:-false}"
            ;;
        set)
            local key="$2"
            local value="$3"
            echo "export $key='$value'" >> "$CONFIG_DIR/env.llm"
            log "Set $key"
            ;;
        *)
            error "Unknown config action: $action"
            ;;
    esac
}

handle_auth() {
    local action="${1:-status}"

    case "$action" in
        status)
            echo "Authentication Status:"
            echo "  Portkey: $([ -n "${PORTKEY_API_KEY:-}" ] && echo "Configured" || echo "Not configured")"
            echo "  GPT-5 (ChatGPT): $([ -f ~/.codex/auth.json ] && echo "Logged in" || echo "Not logged in")"
            ;;
        login)
            log "Opening ChatGPT login for GPT-5-Codex access..."
            codex /login
            ;;
        *)
            error "Unknown auth action: $action"
            ;;
    esac
}

handle_memory() {
    local command="$1"
    shift

    # Use Python memory system
    local memory_script="$PAYREADY_BIN/../core/memory.py"

    case "$command" in
        remember)
            if [[ $# -lt 2 ]]; then
                error "Usage: ai remember <key> <value> [category]"
            fi
            source .venv/bin/activate && python "$memory_script" remember "$@"
            ;;
        recall)
            if [[ $# -lt 1 ]]; then
                error "Usage: ai recall <query> [category]"
            fi
            source .venv/bin/activate && python "$memory_script" recall "$@"
            ;;
        memory)
            local action="${1:-context}"
            case "$action" in
                context)
                    source .venv/bin/activate && python "$memory_script" context
                    ;;
                *)
                    echo "Memory commands:"
                    echo "  ai remember <key> <value> [category]  - Store information"
                    echo "  ai recall <query> [category]          - Search memory"
                    echo "  ai memory context                     - Show current context"
                    ;;
            esac
            ;;
    esac
}

run_tests() {
    log "Running system tests..."

    # Test Portkey
    echo -n "Testing Portkey connection... "
    if curl -s -I https://api.portkey.ai/v1/models \
        -H "x-portkey-api-key: ${PORTKEY_API_KEY}" | grep -q "200"; then
        echo -e "${GREEN}✓${NC}"
    else
        echo -e "${RED}✗${NC}"
    fi

    # Test models
    for intent in design analyze; do
        local model=$(select_model "$intent")
        echo -n "Testing $model... "
        if execute_portkey "Say 'OK'" "$model" "$(get_virtual_key "$intent")" | grep -qi "ok"; then
            echo -e "${GREEN}✓${NC}"
        else
            echo -e "${RED}✗${NC}"
        fi
    done
}

run_doctor() {
    local intents=(code analyze design search fast deep general)

    if [[ -n "${PORTKEY_API_KEY:-}" ]]; then
        echo "Portkey Virtual Key checks:"
        for intent in "${intents[@]}"; do
            local model=$(select_model "$intent")
            local vk=$(get_virtual_key "$intent")
            local payload
            payload=$(printf '{"model":"%s","messages":[{"role":"user","content":"ping"}]}' "$model")
            local tmp
            tmp=$(mktemp)
            set +e
            local status
            status=$(curl -sS --fail-with-body \
                -o "$tmp" \
                -w '%{http_code}' \
                "${PORTKEY_BASE_URL:-https://api.portkey.ai/v1}/chat/completions" \
                -H "content-type: application/json" \
                -H "x-portkey-api-key: ${PORTKEY_API_KEY}" \
                -H "x-portkey-virtual-key: ${vk}" \
                -d "$payload")
            local exit_code=$?
            set -e
            if [[ $exit_code -eq 0 && ${status:-0} -lt 400 ]]; then
                echo -e "  ${GREEN}✓${NC} $intent → $model (HTTP $status)"
            else
                echo -e "  ${RED}✗${NC} $intent → $model (HTTP ${status:-n/a})"
                if [[ -s "$tmp" ]]; then
                    echo "    $(head -c 120 "$tmp")"
                fi
            fi
            rm -f "$tmp"
        done
    else
        echo -e "${YELLOW}!${NC} PORTKEY_API_KEY not set; skipping Portkey checks."
    fi

    if [[ -n "${OPENROUTER_API_KEY:-}" ]]; then
        echo "OpenRouter fallback check:"
        local tmp
        tmp=$(mktemp)
        set +e
        local or_status
        or_status=$(curl -sS --fail-with-body \
            -o "$tmp" \
            -w '%{http_code}' \
            https://openrouter.ai/api/v1/chat/completions \
            -H "authorization: Bearer ${OPENROUTER_API_KEY}" \
            -H "content-type: application/json" \
            -H "http-referer: ${OPENROUTER_REFERER:-https://payready.ai/tools}" \
            -H "x-title: ${OPENROUTER_TITLE:-PayReady CLI}" \
            -d '{"model":"openai/gpt-4.1-mini","messages":[{"role":"user","content":"ping"}]}')
        local or_exit=$?
        set -e
        if [[ $or_exit -eq 0 && ${or_status:-0} -lt 400 ]]; then
            echo -e "  ${GREEN}✓${NC} OpenRouter (HTTP $or_status)"
        else
            echo -e "  ${RED}✗${NC} OpenRouter (HTTP ${or_status:-n/a})"
            if [[ -s "$tmp" ]]; then
                echo "    $(head -c 120 "$tmp")"
            fi
        fi
        rm -f "$tmp"
    fi
}

# ============================================================================
# Usage Information
# ============================================================================

show_usage() {
    cat <<EOF
${GREEN}PayReady AI Unified CLI v3.0${NC}

${YELLOW}Usage:${NC}
    ai [options] <query>
    ai <command> [args]

${YELLOW}Options:${NC}
    --model, -m <model>   Use specific model
    --verbose, -v         Verbose output
    --help, -h           Show this help

${YELLOW}Commands:${NC}
    config list          Show configuration
    config set KEY VAL   Set configuration value
    auth status          Show auth status
    auth login           Login to ChatGPT (for GPT-5)
    test                 Run system tests
    doctor               Validate Portkey/OpenRouter connectivity
    remember KEY VAL     Store information in memory
    recall QUERY         Search memory for information
    memory context       Show current memory context

${YELLOW}Examples:${NC}
    ai "write a hello world function"
    ai --model opus "analyze this codebase"
    ai --verbose "design a microservices architecture"

${YELLOW}Models (via Portkey/OpenRouter):${NC}
    x-ai/grok-code-fast-1           Grok Code Fast
    google/gemini-2.5-flash         Gemini 2.5 Flash
    google/gemini-2.5-pro          Gemini 2.5 Pro
    openai/gpt-4.1-mini            GPT-4.1 Mini
    openai/gpt-5-mini              GPT-5 Mini
    deepseek/deepseek-chat-v3-0324 DeepSeek Chat v3
    openai/gpt-oss-120b            GPT-OSS 120B
    meta-llama/llama-4-maverick    Llama 4 Maverick
    meta-llama/llama-4-scout       Llama 4 Scout
    qwen/qwen3-coder-flash         Qwen3 Coder Flash
    qwen/qwen3-coder-plus          Qwen3 Coder Plus
    anthropic/claude-opus-4.1      Claude Opus 4.1
    anthropic/claude-sonnet-4      Claude Sonnet 4

${CYAN}Pro tip:${NC} The CLI automatically selects the best model based on your query!
EOF
}

# ============================================================================
# Entry Point
# ============================================================================

main "$@"
